package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"html/template"
	"io"
	"os"
	"reflect"
	"strings"
)

func Generate(pkg string, filepath string, objs ...interface{}) error {
	buf := bytes.NewBuffer(nil)
	ctx := &genContext{Package: pkg, Imported: generateImports(objs...)}

	err := executeTemplate(buf, `// Code generated by github.com/spacemeshos/go-scale/gen. DO NOT EDIT.

	package {{ .Package }}
	
	import (
		"io"

		"github.com/spacemeshos/go-scale"
		{{ range $pkg, $short := .Imported }}"{{ $pkg }}"
        {{ end }}
	)
	`, ctx)
	if err != nil {
		return err
	}

	for _, obj := range objs {
		if err := generateType(buf, ctx, obj); err != nil {
			return err
		}
	}
	data := buf.Bytes()
	data, err = format.Source(data)
	if err != nil {
		return fmt.Errorf("can't format: \ndata: %s\n err:%w", buf.Bytes(), err)
	}
	return os.WriteFile(filepath, data, 0o664)
}

func generateImports(objs ...interface{}) map[string]struct{} {
	rst := map[string]struct{}{}
	for _, obj := range objs {
		typ := reflect.TypeOf(obj)
		for i := 0; i < typ.NumField(); i++ {
			field := typ.Field(i)
			if sameModule(field.Type, typ) {
				continue
			}
			if private(field) {
				continue
			}
			if builtin(field.Type) {
				continue
			}
			if needsImport(field.Type) {
				rst[canonicalPath(field.Type)] = struct{}{}
			}
		}
	}
	return rst
}

func canonicalPath(typ reflect.Type) string {
	if typ.Kind() == reflect.Ptr {
		return typ.Elem().PkgPath()
	}
	return typ.PkgPath()
}

func private(field reflect.StructField) bool {
	return strings.ToUpper(field.Name[:1]) != field.Name[:1]
}

func sameModule(a, b reflect.Type) bool {
	if b.Kind() == reflect.Ptr {
		b = b.Elem()
	}
	if a.Kind() == reflect.Ptr {
		a = a.Elem()
	}
	return a.PkgPath() == b.PkgPath()
}

func builtin(typ reflect.Type) bool {
	if typ.Kind() == reflect.Ptr {
		return typ.Elem().PkgPath() == ""
	}
	return typ.PkgPath() == ""
}

func needsImport(typ reflect.Type) bool {
	switch typ.Kind() {
	case reflect.Ptr:
		return true
	case reflect.Slice:
		return true
	}
	return false
}

func generateType(w io.Writer, gc *genContext, obj interface{}) error {
	typ := reflect.TypeOf(obj)
	tc := &typeContext{Name: typ.Name(), Type: typ, ParentPackage: typ.PkgPath()}
	if err := encodeMethod(w, tc); err != nil {
		return err
	}
	// if err := unmarshalMethod(w, gc, tc); err != nil {
	// 	return err
	// }
	return nil
}

type genContext struct {
	Package  string
	Imported map[string]struct{} // full path to shortname
}

type typeContext struct {
	Name          string
	ScaleType     string
	TypeName      string
	Type          reflect.Type
	ParentPackage string
}

func getScaleType(t reflect.Type) (string, error) {
	switch t.Kind() {
	case reflect.Bool:
		return "Bool", nil
	case reflect.Uint8:
		return "Compact8", nil
	case reflect.Uint16:
		return "Compact16", nil
	case reflect.Uint32:
		return "Compact32", nil
	case reflect.Uint64:
		return "Compact64", nil
	case reflect.Struct:
		return "Struct", nil
	case reflect.Ptr:
		return "Option", nil
	case reflect.Slice:
		return "StructSlice", nil
	case reflect.Array:
		return "StructArray", nil
	}
	return "", fmt.Errorf("type %v is not supported", t.Kind())
}

func encodeMethod(w io.Writer, tc *typeContext) error {
	typ := tc.Type
	if err := executeTemplate(w, encodeMethodStart, tc); err != nil {
		return err
	}
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if private(field) {
			continue
		}

		stype, err := getScaleType(field.Type)
		if err != nil {
			return err
		}
		tctx := &typeContext{
			Name:      field.Name,
			Type:      field.Type,
			ScaleType: stype,
		}

		fmt.Fprintf(w, "// field %v (%d)\n", field.Name, i)
		if err := executeTemplate(w, encodeTemplate, tctx); err != nil {
			return err
		}
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w, "return total, nil")
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)
	return nil
}

func marshalField(w io.Writer, tc *typeContext) error {
	switch tc.Type.Kind() {
	case reflect.Bool:
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Uint16:
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Uint32:
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Uint64:
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Struct:
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Ptr:
		switch tc.Type.Elem().Kind() {
		case reflect.Array:
			return errors.New("ptr to array is not supported")
		case reflect.Slice:
			return errors.New("ptr to slice is not supported")
		}
		if err := executeTemplate(w, encodeTemplate, tc); err != nil {
			return err
		}
	case reflect.Slice:
		elem := tc.Type.Elem()
		if elem.Kind() == reflect.Uint8 {
			if err := executeTemplate(w, encodeTemplate, tc); err != nil {
				return err
			}
		} else {
			if err := executeTemplate(w, encodeTemplate, tc); err != nil {
				return err
			}
		}
	case reflect.Array:
		elem := tc.Type.Elem()
		if elem.Kind() == reflect.Uint8 {
			if err := executeTemplate(w, encodeTemplate, tc); err != nil {
				return err
			}
		} else {
			if err := executeTemplate(w, encodeTemplate, tc); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("type %v is not supported", tc.Type.Kind())
	}
	return nil
}

// func unmarshalMethod(w io.Writer, gc *genContext, tc *typeContext) error {
// 	typ := tc.Type
// 	if err := executeTemplate(w, unmarshalStart, tc); err != nil {
// 		return err
// 	}
// 	for i := 0; i < typ.NumField(); i++ {
// 		field := typ.Field(i)
// 		if private(field) {
// 			continue
// 		}

// 		tctx := &typeContext{
// 			Name:          field.Name,
// 			Type:          field.Type,
// 			TypeName:      fullTypeName(gc, tc, field.Type),
// 			Index:         indexVar,
// 			ParentPackage: tc.ParentPackage,
// 		}
// 		fmt.Fprintf(w, "// field %v (%d)\n", field.Name, i)
// 		if err := unmarshalField(w, gc, tctx); err != nil {
// 			return err
// 		}
// 		fmt.Fprintln(w)
// 	}
// 	fmt.Fprintln(w, "return nil")
// 	fmt.Fprintln(w, "}")
// 	fmt.Fprintln(w)
// 	return nil
// }

// func unmarshalField(w io.Writer, gc *genContext, tc *typeContext) error {
// 	switch tc.Type.Kind() {
// 	case reflect.Bool:
// 		if err := executeTemplate(w, unmarshalBool, tc); err != nil {
// 			return err
// 		}
// 	case reflect.Uint32:
// 		if err := executeTemplate(w, unmarshalUint32, tc); err != nil {
// 			return err
// 		}
// 	case reflect.Struct:
// 		if err := executeTemplate(w, unmarshalStruct, tc); err != nil {
// 			return err
// 		}
// 	case reflect.Ptr:
// 		switch tc.Type.Elem().Kind() {
// 		case reflect.Array:
// 			return errors.New("ptr to array is not supported")
// 		case reflect.Slice:
// 			return errors.New("ptr to slice is not supported")
// 		}
// 		if err := executeTemplate(w, unmarshalPtr, tc); err != nil {
// 			return err
// 		}
// 	case reflect.Slice:
// 		if err := executeTemplate(w, unmarshalSlice, tc); err != nil {
// 			return err
// 		}
// 		fallthrough
// 	case reflect.Array:
// 		elem := tc.Type.Elem()
// 		if elem.Kind() == reflect.Uint8 {
// 			if err := executeTemplate(w, unmarshalBytes, tc); err != nil {
// 				return err
// 			}
// 		} else {
// 			if err := executeTemplate(w, addLoop, tc); err != nil {
// 				return err
// 			}
// 			if err := unmarshalField(w, gc, &typeContext{
// 				Name:          fmt.Sprintf("%s[%s]", tc.Name, tc.Index),
// 				Type:          elem,
// 				TypeName:      fullTypeName(gc, tc, elem),
// 				Index:         tc.Index + indexVar,
// 				ParentPackage: tc.ParentPackage,
// 			}); err != nil {
// 				return err
// 			}
// 			fmt.Fprintln(w, "}")
// 		}
// 	default:
// 		return fmt.Errorf("type %v is not supported", tc.Type.Kind())
// 	}
// 	return nil
// }

func fullTypeName(gc *genContext, tc *typeContext, typ reflect.Type) string {
	pkg := typ.PkgPath()
	name := typ.Name()
	str := typ.String()
	if typ.Kind() == reflect.Ptr {
		pkg = typ.Elem().PkgPath()
		name = typ.Elem().Name()
		str = typ.Elem().String()
	}

	// FIXME this needs to go deeper in order to support nested aliases
	if typ.Kind() == reflect.Slice {
		if typ.Elem().PkgPath() == tc.ParentPackage {
			return "[]" + typ.Elem().Name()
		}
	}
	if tc.ParentPackage == pkg {
		return name
	}
	return str
}

func executeTemplate(w io.Writer, text string, ctx interface{}) error {
	tpl, err := template.New("").Parse(text)
	if err != nil {
		return err
	}
	return tpl.Execute(w, ctx)
}
